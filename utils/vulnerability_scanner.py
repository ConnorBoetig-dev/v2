"""
Vulnerability Scanner - Multi-source CVE correlation engine

This module provides automated vulnerability assessment by correlating discovered
services with multiple vulnerability databases. It uses a cascading approach with
multiple free APIs to ensure comprehensive coverage without requiring API keys.

Key Features:
- Multi-API support (OSV, CIRCL) with automatic fallback
- Local vulnerability patterns for offline operation
- Intelligent caching to minimize API calls
- Service version extraction and matching
- CVSS scoring and severity classification

Design Philosophy:
- Zero-configuration: Works out of the box without API keys
- Graceful degradation: Falls back to local patterns if APIs fail
- Performance conscious: Caches results and rate limits requests
- Privacy aware: No device data sent to APIs, only service names
"""

import json
import logging
import re
import time
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import requests

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans for known vulnerabilities in discovered services"""

    def __init__(self, cache_dir: Path = None):
        """
        Initialize vulnerability scanner with multi-API configuration.

        Sets up the cascading API system with OSV as primary and CIRCL as fallback.
        Creates cache directory for storing CVE lookups to minimize API calls.
        Configures rate limiting to be respectful of free services.

        Args:
            cache_dir: Directory to cache CVE data (defaults to output/cache/cve)
        """
        # Multi-API configuration
        self.apis = {
            "osv": {"url": "https://api.osv.dev/v1/query", "name": "OSV (Google)", "enabled": True},
            "circl": {
                "url": "https://cve.circl.lu/api/cve",
                "name": "CIRCL CVE Search",
                "enabled": True,
            },
        }

        self.cache_dir = cache_dir or Path("output/cache/cve")
        self.cache_dir.mkdir(parents=True, exist_ok=True)

        # Rate limiting (be respectful to free APIs)
        self.request_interval = 2  # seconds between requests
        self.last_request_time = 0

        # Service to CVE keyword mappings
        self.service_keywords = {
            "apache": ["apache", "httpd"],
            "nginx": ["nginx"],
            "mysql": ["mysql"],
            "postgresql": ["postgresql", "postgres"],
            "ssh": ["openssh", "ssh"],
            "ftp": ["vsftpd", "proftpd", "filezilla"],
            "telnet": ["telnet"],
            "smtp": ["postfix", "sendmail", "exim"],
            "dns": ["bind", "dnsmasq"],
            "dhcp": ["isc-dhcp", "dhcp"],
            "snmp": ["net-snmp", "snmp"],
            "ntp": ["ntp", "chrony"],
            "samba": ["samba", "smb"],
            "cups": ["cups"],
            "docker": ["docker"],
            "kubernetes": ["kubernetes", "k8s"],
            "jenkins": ["jenkins"],
            "tomcat": ["tomcat"],
            "jboss": ["jboss"],
            "weblogic": ["weblogic"],
            "iis": ["iis", "microsoft"],
            "exchange": ["exchange"],
            "sharepoint": ["sharepoint"],
        }

    def scan_devices(self, devices: List[Dict]) -> List[Dict]:
        """
        Scan devices for vulnerabilities using multi-source correlation.

        This is the main entry point that orchestrates the vulnerability scanning process.
        For each device, it attempts to find CVEs through:
        1. API lookups (OSV primary, CIRCL fallback)
        2. Local vulnerability patterns if APIs fail
        3. Enriches devices with vulnerability counts and severity breakdowns

        The function is resilient - if scanning fails for a device, it still includes
        the device in results with empty vulnerability data rather than failing entirely.

        Args:
            devices: List of device dictionaries containing:
                - services: List of service strings with versions
                - open_ports: List of open port numbers
                - Other device metadata

        Returns:
            List of devices with added vulnerability fields:
                - vulnerabilities: List of CVE dictionaries
                - vulnerability_count: Total number of CVEs found
                - critical_vulns: Count of CRITICAL severity CVEs
                - high_vulns: Count of HIGH severity CVEs
        """
        if not devices:
            return devices

        logger.info(f"Starting vulnerability scan for {len(devices)} devices")

        enriched_devices = []
        total_vulns = 0

        for device in devices:
            try:
                device_copy = device.copy()

                # Try to get vulnerabilities from API
                vulnerabilities = self._scan_device_services(device_copy)

                # If API fails, use local vulnerability knowledge
                if not vulnerabilities:
                    vulnerabilities = self._get_local_vulnerabilities(device_copy)

                if vulnerabilities:
                    device_copy["vulnerabilities"] = vulnerabilities
                    device_copy["vulnerability_count"] = len(vulnerabilities)
                    device_copy["critical_vulns"] = len(
                        [v for v in vulnerabilities if v.get("severity") == "CRITICAL"]
                    )
                    device_copy["high_vulns"] = len(
                        [v for v in vulnerabilities if v.get("severity") == "HIGH"]
                    )
                    total_vulns += len(vulnerabilities)
                else:
                    device_copy["vulnerabilities"] = []
                    device_copy["vulnerability_count"] = 0
                    device_copy["critical_vulns"] = 0
                    device_copy["high_vulns"] = 0

                enriched_devices.append(device_copy)

            except Exception as e:
                logger.error(f"Error scanning device {device.get('ip')}: {e}")
                # Always add the device, even if scanning fails
                device_copy = device.copy()
                device_copy["vulnerabilities"] = []
                device_copy["vulnerability_count"] = 0
                device_copy["critical_vulns"] = 0
                device_copy["high_vulns"] = 0
                enriched_devices.append(device_copy)

        logger.info(f"Vulnerability scan complete: {total_vulns} vulnerabilities found")
        return enriched_devices

    def _scan_device_services(self, device: Dict) -> List[Dict]:
        """
        Scan services on a device for vulnerabilities.

        Implements the cascading lookup strategy:
        1. Try API lookups for each service (with caching)
        2. If no results, fall back to local vulnerability patterns

        This separation allows us to gracefully degrade when APIs are unavailable
        while still providing basic security assessment capabilities.

        Args:
            device: Device dictionary containing services list

        Returns:
            List of vulnerability dictionaries from all sources
        """
        services = device.get("services", [])
        if not services:
            return []

        vulnerabilities = []

        # Try APIs first (OSV, then CIRCL as fallback)
        for service in services:
            service_vulns = self._get_service_vulnerabilities(service)
            vulnerabilities.extend(service_vulns)

        # If no API results, use local knowledge as final fallback
        if not vulnerabilities:
            vulnerabilities = self._get_local_vulnerabilities(device)

        return vulnerabilities

    def _get_service_vulnerabilities(self, service: str) -> List[Dict]:
        """
        Get vulnerabilities for a specific service.

        This method handles the complete lookup process for a single service:
        1. Parses the service string to extract name and version
        2. Maps service name to searchable keywords
        3. Checks cache to avoid redundant API calls
        4. Queries multiple APIs if cache miss
        5. Caches results for future lookups

        The caching strategy significantly reduces API load and improves
        performance for repeated scans of similar networks.

        Args:
            service: Service string (e.g., "http:80 (Apache 2.4.41)")

        Returns:
            List of vulnerability dictionaries with CVE details
        """
        # Parse service string to extract service name and version
        service_info = self._parse_service_string(service)
        if not service_info:
            return []

        service_name, version = service_info

        # Get keywords for this service
        keywords = self._get_service_keywords(service_name)
        if not keywords:
            return []

        vulnerabilities = []

        for keyword in keywords:
            # Check cache first
            cache_file = self._get_cache_file(keyword, version)
            cached_vulns = self._load_from_cache(cache_file)

            if cached_vulns is not None:
                vulnerabilities.extend(cached_vulns)
                continue

            # Try APIs in order: OSV first, then CIRCL as fallback
            api_vulns = self._query_multi_apis(keyword, version)

            if api_vulns:
                # Cache the results
                self._save_to_cache(cache_file, api_vulns)
                vulnerabilities.extend(api_vulns)

        return vulnerabilities

    def _parse_service_string(self, service: str) -> Optional[Tuple[str, str]]:
        """
        Parse service string to extract name and version.

        Handles various service string formats from different scanners:
        - "http:80 (Apache 2.4.41)" → ("http", "2.4.41")
        - "ssh:22 (OpenSSH 7.4)" → ("ssh", "7.4")
        - "mysql:3306" → ("mysql", "unknown")

        The parser is resilient to malformed input and extracts whatever
        information is available, defaulting to "unknown" for missing versions.

        Args:
            service: Service string from scanner output

        Returns:
            Tuple of (service_name, version) or None if unparseable
        """
        # Examples:
        # "http:80 (Apache 2.4.41)"
        # "ssh:22 (OpenSSH 7.4)"
        # "mysql:3306"

        try:
            # Extract service name from port info
            if ":" in service:
                service_part = service.split(":")[0].lower()
            else:
                service_part = service.lower()

            # Extract version from parentheses
            version = None
            if "(" in service and ")" in service:
                paren_content = service.split("(")[1].split(")")[0]
                # Look for version patterns
                version_match = re.search(r"(\d+\.\d+(?:\.\d+)?)", paren_content)
                if version_match:
                    version = version_match.group(1)

            return service_part, version or "unknown"

        except Exception as e:
            logger.warning(f"Failed to parse service string '{service}': {e}")
            return None

    def _get_service_keywords(self, service_name: str) -> List[str]:
        """
        Get CVE search keywords for a service.

        Maps generic service names to specific product names for better
        CVE matching. For example, "http" maps to ["apache", "httpd"]
        since these are more likely to return relevant CVEs.

        If no mapping exists, returns the service name itself as a fallback.

        Args:
            service_name: Generic service name (e.g., "http", "ssh")

        Returns:
            List of keywords to search for in CVE databases
        """
        return self.service_keywords.get(service_name, [service_name])

    def _query_multi_apis(self, keyword: str, version: str = None) -> List[Dict]:
        """
        Query multiple APIs for vulnerabilities using cascading strategy.

        Implements the multi-API approach:
        1. Try OSV (Google) API first - most comprehensive
        2. If no results, try CIRCL as fallback - community maintained
        3. Return combined results from successful queries

        This cascading approach ensures maximum coverage while handling
        API failures gracefully. Each API has different strengths:
        - OSV: Better for open source software
        - CIRCL: Better for commercial/proprietary software

        Args:
            keyword: Service keyword to search for
            version: Version string (optional)

        Returns:
            List of vulnerability dictionaries from all successful queries
        """
        vulnerabilities = []

        # Try OSV API first
        osv_vulns = self._query_osv_api(keyword, version)
        if osv_vulns:
            vulnerabilities.extend(osv_vulns)
            logger.debug(f"OSV API: Found {len(osv_vulns)} vulnerabilities for {keyword}")

        # If OSV didn't return results, try CIRCL as fallback
        if not vulnerabilities:
            circl_vulns = self._query_circl_api(keyword, version)
            if circl_vulns:
                vulnerabilities.extend(circl_vulns)
                logger.debug(f"CIRCL API: Found {len(circl_vulns)} vulnerabilities for {keyword}")

        return vulnerabilities

    def _query_osv_api(self, keyword: str, version: str = None) -> List[Dict]:
        """
        Query OSV (Open Source Vulnerabilities) API.

        OSV is Google's vulnerability database that aggregates CVEs from
        multiple sources. It's our primary API because:
        - No API key required
        - Comprehensive coverage of open source software
        - Fast response times
        - Well-maintained and reliable

        The API uses POST requests with JSON payloads for flexible querying.

        Args:
            keyword: Service keyword to search for
            version: Version string (optional, improves accuracy)

        Returns:
            List of processed vulnerability dictionaries
        """
        try:
            self._rate_limit()

            # OSV API uses POST with JSON payload
            query_data = {"query": keyword}

            # Add version if available
            if version and version != "unknown":
                query_data["version"] = version

            response = requests.post(
                self.apis["osv"]["url"],
                json=query_data,
                headers={"Content-Type": "application/json"},
                timeout=10,
            )

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                # OSV returns 'vulns' array
                for vuln in data.get("vulns", []):
                    vuln_data = self._process_osv_data(vuln, keyword, version)
                    if vuln_data:
                        vulnerabilities.append(vuln_data)

                return vulnerabilities

            else:
                logger.debug(f"OSV API request failed: {response.status_code}")
                return []

        except Exception as e:
            logger.debug(f"Error querying OSV API for {keyword}: {e}")
            return []

    def _query_circl_api(self, keyword: str, version: str = None) -> List[Dict]:
        """
        Query CIRCL CVE Search API.

        CIRCL (Computer Incident Response Center Luxembourg) maintains
        a free CVE search API that mirrors the NVD database. Used as
        fallback because:
        - Different CVE coverage than OSV
        - No API key required
        - Good for commercial software CVEs
        - Community-maintained

        We limit results to 10 to avoid overwhelming the response processing.

        Args:
            keyword: Service keyword to search for
            version: Version string (optional, used for filtering)

        Returns:
            List of processed vulnerability dictionaries
        """
        try:
            self._rate_limit()

            # CIRCL API search endpoint
            search_url = f"https://cve.circl.lu/api/search/{keyword}"

            response = requests.get(search_url, timeout=10)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                # CIRCL returns array of CVE objects
                for cve in data[:10]:  # Limit to first 10 results
                    vuln_data = self._process_circl_data(cve, keyword, version)
                    if vuln_data:
                        vulnerabilities.append(vuln_data)

                return vulnerabilities

            else:
                logger.debug(f"CIRCL API request failed: {response.status_code}")
                return []

        except Exception as e:
            logger.debug(f"Error querying CIRCL API for {keyword}: {e}")
            return []

    def _process_osv_data(self, vuln_data: Dict, keyword: str, version: str) -> Optional[Dict]:
        """
        Process vulnerability data from OSV API into standardized format.

        OSV returns data in a specific format that needs normalization.
        This method:
        1. Extracts CVE ID and description
        2. Determines severity from multiple possible fields
        3. Calculates CVSS score (or derives from severity)
        4. Formats dates consistently
        5. Adds relevance scoring for result ranking

        The standardized format ensures consistent handling regardless
        of which API provided the data.

        Args:
            vuln_data: Raw vulnerability data from OSV API
            keyword: Service keyword (for relevance scoring)
            version: Service version (for relevance scoring)

        Returns:
            Processed vulnerability dictionary or None if processing fails
        """
        try:
            vuln_id = vuln_data.get("id", "Unknown")
            summary = vuln_data.get("summary", "No description available")

            # Get severity score from database_specific or severity array
            cvss_score = 0.0
            severity = "UNKNOWN"

            # Try database_specific first
            db_specific = vuln_data.get("database_specific", {})
            if "severity" in db_specific:
                severity = db_specific["severity"].upper()
                cvss_score = self._severity_to_score(severity)

            # Try severity array
            severity_list = vuln_data.get("severity", [])
            if severity_list and not cvss_score:
                for sev in severity_list:
                    if sev.get("type") == "CVSS_V3":
                        cvss_score = float(sev.get("score", 0))
                        severity = self._score_to_severity(cvss_score)
                        break

            # Get published date
            published = vuln_data.get("published", "")
            if published:
                try:
                    pub_date = datetime.fromisoformat(published.replace("Z", "+00:00"))
                    published = pub_date.strftime("%Y-%m-%d")
                except:
                    published = published[:10] if len(published) >= 10 else ""

            return {
                "cve_id": vuln_id,
                "description": summary[:200] + "..." if len(summary) > 200 else summary,
                "cvss_score": cvss_score,
                "severity": severity,
                "published": published,
                "service": keyword,
                "version": version,
                "relevance_score": self._calculate_relevance(summary, keyword, version),
                "source": "OSV",
            }

        except Exception as e:
            logger.warning(f"Error processing OSV data: {e}")
            return None

    def _process_circl_data(self, cve_data: Dict, keyword: str, version: str) -> Optional[Dict]:
        """
        Process CVE data from CIRCL API into standardized format.

        CIRCL returns data in NVD-style format which differs from OSV.
        This method performs similar normalization to ensure consistent
        output regardless of source API.

        Key differences from OSV:
        - CVSS scores are directly provided
        - Different field names for dates and summaries
        - Simpler severity calculation

        Args:
            cve_data: Raw CVE data from CIRCL API
            keyword: Service keyword (for relevance scoring)
            version: Service version (for relevance scoring)

        Returns:
            Processed vulnerability dictionary or None if processing fails
        """
        try:
            cve_id = cve_data.get("id", "Unknown")
            summary = cve_data.get("summary", "No description available")

            # Get CVSS score and severity
            cvss_score = float(cve_data.get("cvss", 0))
            severity = self._score_to_severity(cvss_score)

            # Get published date
            published = cve_data.get("Published", "")
            if published:
                try:
                    published = published[:10]  # YYYY-MM-DD format
                except:
                    published = ""

            return {
                "cve_id": cve_id,
                "description": summary[:200] + "..." if len(summary) > 200 else summary,
                "cvss_score": cvss_score,
                "severity": severity,
                "published": published,
                "service": keyword,
                "version": version,
                "relevance_score": self._calculate_relevance(summary, keyword, version),
                "source": "CIRCL",
            }

        except Exception as e:
            logger.warning(f"Error processing CIRCL data: {e}")
            return None

    def _severity_to_score(self, severity: str) -> float:
        """
        Convert severity string to approximate CVSS score.

        When APIs provide severity levels without scores, this method
        estimates a reasonable CVSS score for consistency. The mapping
        uses the midpoint of each CVSS v3 severity range.

        Args:
            severity: Severity string (CRITICAL, HIGH, MEDIUM, LOW)

        Returns:
            Estimated CVSS score (0.0-10.0)
        """
        severity_map = {"CRITICAL": 9.0, "HIGH": 7.5, "MEDIUM": 5.0, "MODERATE": 5.0, "LOW": 2.5}
        return severity_map.get(severity.upper(), 0.0)

    def _score_to_severity(self, score: float) -> str:
        """
        Convert CVSS score to severity string.

        Uses CVSS v3 scoring ranges:
        - 9.0-10.0: CRITICAL
        - 7.0-8.9: HIGH
        - 4.0-6.9: MEDIUM
        - 0.1-3.9: LOW

        Args:
            score: CVSS score (0.0-10.0)

        Returns:
            Severity level string
        """
        if score >= 9.0:
            return "CRITICAL"
        elif score >= 7.0:
            return "HIGH"
        elif score >= 4.0:
            return "MEDIUM"
        else:
            return "LOW"

    def _calculate_relevance(self, description: str, keyword: str, version: str) -> float:
        """
        Calculate relevance score for a CVE.

        Relevance scoring helps prioritize CVEs that are most likely to
        affect the specific service. The algorithm considers:
        1. Exact keyword matches in description (0.5 points)
        2. Version string matches (0.3 points)
        3. Generic vulnerability terms (0.1 points)

        This scoring helps filter out false positives from broad API queries.

        Args:
            description: CVE description text
            keyword: Service keyword being searched
            version: Service version being searched

        Returns:
            Relevance score (0.0 to 1.0)
        """
        score = 0.0
        description_lower = description.lower()

        # Exact keyword match
        if keyword.lower() in description_lower:
            score += 0.5

        # Version match
        if version != "unknown" and version in description_lower:
            score += 0.3

        # Generic service terms
        service_terms = [
            "remote",
            "denial of service",
            "buffer overflow",
            "injection",
            "authentication",
        ]
        for term in service_terms:
            if term in description_lower:
                score += 0.1
                break

        return min(score, 1.0)

    def _rate_limit(self):
        """
        Implement rate limiting for API requests.

        Ensures we don't overwhelm free APIs with requests. The 2-second
        interval is conservative but respectful of services that provide
        free access without authentication.

        This method tracks the last request time and sleeps if necessary
        to maintain the configured request interval.
        """
        current_time = time.time()
        time_since_last = current_time - self.last_request_time

        if time_since_last < self.request_interval:
            sleep_time = self.request_interval - time_since_last
            time.sleep(sleep_time)

        self.last_request_time = time.time()

    def _get_cache_file(self, keyword: str, version: str) -> Path:
        """
        Get cache file path for keyword/version combination.

        Creates a deterministic filename based on the service and version
        to enable efficient caching. Version dots are replaced with underscores
        to ensure valid filenames across all operating systems.

        Args:
            keyword: Service keyword
            version: Service version

        Returns:
            Path to cache file in cache directory
        """
        filename = f"{keyword}_{version.replace('.', '_')}.json"
        return self.cache_dir / filename

    def _load_from_cache(self, cache_file: Path) -> Optional[List[Dict]]:
        """
        Load vulnerabilities from cache if fresh.

        Implements cache expiration to ensure vulnerability data doesn't
        become stale. Cache files older than 24 hours are considered
        expired and will trigger a fresh API lookup.

        This balances performance with data freshness - critical for
        security assessments where new CVEs are published daily.

        Args:
            cache_file: Path to cache file

        Returns:
            List of cached vulnerabilities or None if cache miss/expired
        """
        try:
            if not cache_file.exists():
                return None

            # Check if cache is recent (less than 24 hours old)
            mtime = datetime.fromtimestamp(cache_file.stat().st_mtime)
            if datetime.now() - mtime > timedelta(hours=24):
                return None

            with open(cache_file, "r") as f:
                return json.load(f)

        except Exception as e:
            logger.warning(f"Error loading cache file {cache_file}: {e}")
            return None

    def _save_to_cache(self, cache_file: Path, vulnerabilities: List[Dict]):
        """
        Save vulnerabilities to cache.

        Stores API results to disk to avoid redundant lookups. Cache files
        are JSON formatted for easy inspection and debugging. Failures to
        write cache are logged but don't interrupt the scanning process.

        Args:
            cache_file: Path to cache file
            vulnerabilities: List of vulnerabilities to cache
        """
        try:
            with open(cache_file, "w") as f:
                json.dump(vulnerabilities, f, indent=2)

        except Exception as e:
            logger.warning(f"Error saving cache file {cache_file}: {e}")

    def generate_vulnerability_report(self, devices: List[Dict]) -> Dict:
        """
        Generate comprehensive vulnerability summary report.

        Aggregates vulnerability data across all devices to provide:
        - Overall vulnerability statistics
        - Severity distribution breakdown
        - Top 10 most critical vulnerabilities
        - Affected device counts

        This report is used for executive summaries and to prioritize
        remediation efforts based on risk levels.

        Args:
            devices: List of devices with vulnerability data

        Returns:
            Vulnerability report dictionary containing:
                - total_devices: Number of devices scanned
                - vulnerable_devices: Number with CVEs
                - severity_distribution: Count by severity level
                - top_vulnerabilities: Most critical CVEs
        """
        total_devices = len(devices)
        vulnerable_devices = len([d for d in devices if d.get("vulnerability_count", 0) > 0])

        total_vulns = sum(d.get("vulnerability_count", 0) for d in devices)
        critical_vulns = sum(d.get("critical_vulns", 0) for d in devices)
        high_vulns = sum(d.get("high_vulns", 0) for d in devices)

        # Top vulnerabilities
        all_vulns = []
        for device in devices:
            for vuln in device.get("vulnerabilities", []):
                vuln_copy = vuln.copy()
                vuln_copy["device_ip"] = device.get("ip")
                all_vulns.append(vuln_copy)

        # Sort by CVSS score
        top_vulns = sorted(all_vulns, key=lambda x: x.get("cvss_score", 0), reverse=True)[:10]

        # Severity distribution
        severity_counts = {"CRITICAL": 0, "HIGH": 0, "MEDIUM": 0, "LOW": 0, "UNKNOWN": 0}
        for vuln in all_vulns:
            severity = vuln.get("severity", "UNKNOWN")
            severity_counts[severity] = severity_counts.get(severity, 0) + 1

        return {
            "total_devices": total_devices,
            "vulnerable_devices": vulnerable_devices,
            "total_vulnerabilities": total_vulns,
            "critical_vulnerabilities": critical_vulns,
            "high_vulnerabilities": high_vulns,
            "severity_distribution": severity_counts,
            "top_vulnerabilities": top_vulns,
            "scan_timestamp": datetime.now().isoformat(),
        }

    def _get_local_vulnerabilities(self, device: Dict) -> List[Dict]:
        """
        Get vulnerabilities using local knowledge base when APIs fail.

        This fallback mechanism ensures basic security assessment even when:
        - APIs are unavailable (network issues)
        - Rate limits are exceeded
        - Services aren't found in CVE databases

        The local patterns focus on well-known security issues with common
        services, providing immediate value even in offline scenarios.
        Each pattern includes:
        - Generic CVE ID for tracking
        - Clear description of the security issue
        - Appropriate CVSS score based on risk
        - Consistent severity classification

        Args:
            device: Device dictionary with services and open_ports

        Returns:
            List of vulnerability dictionaries based on local patterns
        """
        vulnerabilities = []
        services = device.get("services", [])
        open_ports = device.get("open_ports", [])

        # Expanded vulnerability patterns based on services and ports
        vuln_patterns = {
            "telnet": {
                "cve_id": "LOCAL-TELNET-001",
                "description": "Telnet transmits data in clear text, allowing potential eavesdropping and credential theft",
                "cvss_score": 7.5,
                "severity": "HIGH",
                "source": "Local Security Assessment",
            },
            "ftp": {
                "cve_id": "LOCAL-FTP-001",
                "description": "FTP may transmit credentials in clear text, enabling credential interception",
                "cvss_score": 6.5,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
            "http": {
                "cve_id": "LOCAL-HTTP-001",
                "description": "HTTP traffic is unencrypted and may expose sensitive data and session cookies",
                "cvss_score": 5.3,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
            "snmp": {
                "cve_id": "LOCAL-SNMP-001",
                "description": "SNMP with default community strings can expose sensitive system information",
                "cvss_score": 5.8,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
            "ssh": {
                "cve_id": "LOCAL-SSH-001",
                "description": "SSH exposed to internet may be subject to brute force attacks",
                "cvss_score": 4.3,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
            "rlogin": {
                "cve_id": "LOCAL-RLOGIN-001",
                "description": "rlogin provides unencrypted remote access with weak authentication",
                "cvss_score": 8.1,
                "severity": "HIGH",
                "source": "Local Security Assessment",
            },
            "finger": {
                "cve_id": "LOCAL-FINGER-001",
                "description": "Finger service can leak user information to potential attackers",
                "cvss_score": 5.3,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
            "netbios": {
                "cve_id": "LOCAL-NETBIOS-001",
                "description": "NetBIOS services can expose system information and enable lateral movement",
                "cvss_score": 6.5,
                "severity": "MEDIUM",
                "source": "Local Security Assessment",
            },
        }

        # Port-specific vulnerabilities (for services without detailed info)
        port_patterns = {
            21: "ftp",
            23: "telnet",
            79: "finger",
            80: "http",
            135: "netbios",
            137: "netbios",
            138: "netbios",
            139: "netbios",
            161: "snmp",
            162: "snmp",
            513: "rlogin",
            445: "netbios",
        }

        # Check services first
        found_services = set()
        for service in services:
            service_lower = service.lower()

            for pattern, vuln_data in vuln_patterns.items():
                if pattern in service_lower and pattern not in found_services:
                    vuln_copy = vuln_data.copy()
                    vuln_copy["service"] = service
                    vuln_copy["published"] = "2024-01-01"
                    vuln_copy["relevance_score"] = 0.8
                    vuln_copy["version"] = "detected"
                    vulnerabilities.append(vuln_copy)
                    found_services.add(pattern)

        # Check open ports for additional vulnerabilities
        for port in open_ports:
            try:
                port_num = int(port)
                if port_num in port_patterns:
                    pattern = port_patterns[port_num]
                    if pattern not in found_services and pattern in vuln_patterns:
                        vuln_data = vuln_patterns[pattern]
                        vuln_copy = vuln_data.copy()
                        vuln_copy["service"] = f"Port {port_num}"
                        vuln_copy["published"] = "2024-01-01"
                        vuln_copy["relevance_score"] = 0.6
                        vuln_copy["version"] = "unknown"
                        vulnerabilities.append(vuln_copy)
                        found_services.add(pattern)
            except (ValueError, TypeError):
                continue

        return vulnerabilities
