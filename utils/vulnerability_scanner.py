"""
Vulnerability Scanner - Correlates device services with CVE databases
Uses the free NVD (National Vulnerability Database) API
"""

import logging
import re
import requests
import time
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import json
from pathlib import Path

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scans for known vulnerabilities in discovered services"""
    
    def __init__(self, cache_dir: Path = None):
        """Initialize vulnerability scanner
        
        Args:
            cache_dir: Directory to cache CVE data
        """
        # Multi-API configuration
        self.apis = {
            'osv': {
                'url': 'https://api.osv.dev/v1/query',
                'name': 'OSV (Google)',
                'enabled': True
            },
            'circl': {
                'url': 'https://cve.circl.lu/api/cve',
                'name': 'CIRCL CVE Search',
                'enabled': True
            }
        }
        
        self.cache_dir = cache_dir or Path("output/cache/cve")
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        
        # Rate limiting (be respectful to free APIs)
        self.request_interval = 2  # seconds between requests
        self.last_request_time = 0
        
        # Service to CVE keyword mappings
        self.service_keywords = {
            'apache': ['apache', 'httpd'],
            'nginx': ['nginx'],
            'mysql': ['mysql'],
            'postgresql': ['postgresql', 'postgres'],
            'ssh': ['openssh', 'ssh'],
            'ftp': ['vsftpd', 'proftpd', 'filezilla'],
            'telnet': ['telnet'],
            'smtp': ['postfix', 'sendmail', 'exim'],
            'dns': ['bind', 'dnsmasq'],
            'dhcp': ['isc-dhcp', 'dhcp'],
            'snmp': ['net-snmp', 'snmp'],
            'ntp': ['ntp', 'chrony'],
            'samba': ['samba', 'smb'],
            'cups': ['cups'],
            'docker': ['docker'],
            'kubernetes': ['kubernetes', 'k8s'],
            'jenkins': ['jenkins'],
            'tomcat': ['tomcat'],
            'jboss': ['jboss'],
            'weblogic': ['weblogic'],
            'iis': ['iis', 'microsoft'],
            'exchange': ['exchange'],
            'sharepoint': ['sharepoint']
        }
        
    def scan_devices(self, devices: List[Dict]) -> List[Dict]:
        """Scan devices for vulnerabilities
        
        Args:
            devices: List of device dictionaries
            
        Returns:
            List of devices with vulnerability data added
        """
        if not devices:
            return devices
            
        logger.info(f"Starting vulnerability scan for {len(devices)} devices")
        
        enriched_devices = []
        total_vulns = 0
        
        for device in devices:
            try:
                device_copy = device.copy()
                
                # Try to get vulnerabilities from API
                vulnerabilities = self._scan_device_services(device_copy)
                
                # If API fails, use local vulnerability knowledge
                if not vulnerabilities:
                    vulnerabilities = self._get_local_vulnerabilities(device_copy)
                
                if vulnerabilities:
                    device_copy['vulnerabilities'] = vulnerabilities
                    device_copy['vulnerability_count'] = len(vulnerabilities)
                    device_copy['critical_vulns'] = len([v for v in vulnerabilities if v.get('severity') == 'CRITICAL'])
                    device_copy['high_vulns'] = len([v for v in vulnerabilities if v.get('severity') == 'HIGH'])
                    total_vulns += len(vulnerabilities)
                else:
                    device_copy['vulnerabilities'] = []
                    device_copy['vulnerability_count'] = 0
                    device_copy['critical_vulns'] = 0
                    device_copy['high_vulns'] = 0
                    
                enriched_devices.append(device_copy)
                
            except Exception as e:
                logger.error(f"Error scanning device {device.get('ip')}: {e}")
                # Always add the device, even if scanning fails
                device_copy = device.copy()
                device_copy['vulnerabilities'] = []
                device_copy['vulnerability_count'] = 0
                device_copy['critical_vulns'] = 0
                device_copy['high_vulns'] = 0
                enriched_devices.append(device_copy)
                
        logger.info(f"Vulnerability scan complete: {total_vulns} vulnerabilities found")
        return enriched_devices
        
    def _scan_device_services(self, device: Dict) -> List[Dict]:
        """Scan services on a device for vulnerabilities
        
        Args:
            device: Device dictionary
            
        Returns:
            List of vulnerability dictionaries
        """
        services = device.get('services', [])
        if not services:
            return []
            
        vulnerabilities = []
        
        # Try APIs first (OSV, then CIRCL as fallback)
        for service in services:
            service_vulns = self._get_service_vulnerabilities(service)
            vulnerabilities.extend(service_vulns)
            
        # If no API results, use local knowledge as final fallback
        if not vulnerabilities:
            vulnerabilities = self._get_local_vulnerabilities(device)
        
        return vulnerabilities
        
    def _get_service_vulnerabilities(self, service: str) -> List[Dict]:
        """Get vulnerabilities for a specific service
        
        Args:
            service: Service string (e.g., "http:80 (Apache 2.4.41)")
            
        Returns:
            List of vulnerability dictionaries
        """
        # Parse service string to extract service name and version
        service_info = self._parse_service_string(service)
        if not service_info:
            return []
            
        service_name, version = service_info
        
        # Get keywords for this service
        keywords = self._get_service_keywords(service_name)
        if not keywords:
            return []
            
        vulnerabilities = []
        
        for keyword in keywords:
            # Check cache first
            cache_file = self._get_cache_file(keyword, version)
            cached_vulns = self._load_from_cache(cache_file)
            
            if cached_vulns is not None:
                vulnerabilities.extend(cached_vulns)
                continue
                
            # Try APIs in order: OSV first, then CIRCL as fallback
            api_vulns = self._query_multi_apis(keyword, version)
            
            if api_vulns:
                # Cache the results
                self._save_to_cache(cache_file, api_vulns)
                vulnerabilities.extend(api_vulns)
                
        return vulnerabilities
        
    def _parse_service_string(self, service: str) -> Optional[Tuple[str, str]]:
        """Parse service string to extract name and version
        
        Args:
            service: Service string
            
        Returns:
            Tuple of (service_name, version) or None
        """
        # Examples:
        # "http:80 (Apache 2.4.41)"
        # "ssh:22 (OpenSSH 7.4)"
        # "mysql:3306"
        
        try:
            # Extract service name from port info
            if ':' in service:
                service_part = service.split(':')[0].lower()
            else:
                service_part = service.lower()
                
            # Extract version from parentheses
            version = None
            if '(' in service and ')' in service:
                paren_content = service.split('(')[1].split(')')[0]
                # Look for version patterns
                version_match = re.search(r'(\d+\.\d+(?:\.\d+)?)', paren_content)
                if version_match:
                    version = version_match.group(1)
                    
            return service_part, version or "unknown"
            
        except Exception as e:
            logger.warning(f"Failed to parse service string '{service}': {e}")
            return None
            
    def _get_service_keywords(self, service_name: str) -> List[str]:
        """Get CVE search keywords for a service
        
        Args:
            service_name: Service name
            
        Returns:
            List of keywords to search for
        """
        return self.service_keywords.get(service_name, [service_name])
        
    def _query_multi_apis(self, keyword: str, version: str = None) -> List[Dict]:
        """Query multiple APIs for vulnerabilities (OSV first, then CIRCL)
        
        Args:
            keyword: Service keyword to search for
            version: Version string (optional)
            
        Returns:
            List of vulnerability dictionaries
        """
        vulnerabilities = []
        
        # Try OSV API first
        osv_vulns = self._query_osv_api(keyword, version)
        if osv_vulns:
            vulnerabilities.extend(osv_vulns)
            logger.debug(f"OSV API: Found {len(osv_vulns)} vulnerabilities for {keyword}")
        
        # If OSV didn't return results, try CIRCL as fallback
        if not vulnerabilities:
            circl_vulns = self._query_circl_api(keyword, version)
            if circl_vulns:
                vulnerabilities.extend(circl_vulns)
                logger.debug(f"CIRCL API: Found {len(circl_vulns)} vulnerabilities for {keyword}")
        
        return vulnerabilities
        
    def _query_osv_api(self, keyword: str, version: str = None) -> List[Dict]:
        """Query OSV (Open Source Vulnerabilities) API
        
        Args:
            keyword: Service keyword to search for
            version: Version string (optional)
            
        Returns:
            List of vulnerability dictionaries
        """
        try:
            self._rate_limit()
            
            # OSV API uses POST with JSON payload
            query_data = {
                "query": keyword
            }
            
            # Add version if available
            if version and version != "unknown":
                query_data["version"] = version
                
            response = requests.post(
                self.apis['osv']['url'],
                json=query_data,
                headers={'Content-Type': 'application/json'},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []
                
                # OSV returns 'vulns' array
                for vuln in data.get('vulns', []):
                    vuln_data = self._process_osv_data(vuln, keyword, version)
                    if vuln_data:
                        vulnerabilities.append(vuln_data)
                        
                return vulnerabilities
                
            else:
                logger.debug(f"OSV API request failed: {response.status_code}")
                return []
                
        except Exception as e:
            logger.debug(f"Error querying OSV API for {keyword}: {e}")
            return []
            
    def _query_circl_api(self, keyword: str, version: str = None) -> List[Dict]:
        """Query CIRCL CVE Search API
        
        Args:
            keyword: Service keyword to search for
            version: Version string (optional)
            
        Returns:
            List of vulnerability dictionaries
        """
        try:
            self._rate_limit()
            
            # CIRCL API search endpoint
            search_url = f"https://cve.circl.lu/api/search/{keyword}"
            
            response = requests.get(search_url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []
                
                # CIRCL returns array of CVE objects
                for cve in data[:10]:  # Limit to first 10 results
                    vuln_data = self._process_circl_data(cve, keyword, version)
                    if vuln_data:
                        vulnerabilities.append(vuln_data)
                        
                return vulnerabilities
                
            else:
                logger.debug(f"CIRCL API request failed: {response.status_code}")
                return []
                
        except Exception as e:
            logger.debug(f"Error querying CIRCL API for {keyword}: {e}")
            return []
            
    def _process_osv_data(self, vuln_data: Dict, keyword: str, version: str) -> Optional[Dict]:
        """Process vulnerability data from OSV API
        
        Args:
            vuln_data: Raw vulnerability data from OSV API
            keyword: Service keyword
            version: Service version
            
        Returns:
            Processed vulnerability dictionary or None
        """
        try:
            vuln_id = vuln_data.get('id', 'Unknown')
            summary = vuln_data.get('summary', 'No description available')
            
            # Get severity score from database_specific or severity array
            cvss_score = 0.0
            severity = 'UNKNOWN'
            
            # Try database_specific first
            db_specific = vuln_data.get('database_specific', {})
            if 'severity' in db_specific:
                severity = db_specific['severity'].upper()
                cvss_score = self._severity_to_score(severity)
            
            # Try severity array
            severity_list = vuln_data.get('severity', [])
            if severity_list and not cvss_score:
                for sev in severity_list:
                    if sev.get('type') == 'CVSS_V3':
                        cvss_score = float(sev.get('score', 0))
                        severity = self._score_to_severity(cvss_score)
                        break
            
            # Get published date
            published = vuln_data.get('published', '')
            if published:
                try:
                    pub_date = datetime.fromisoformat(published.replace('Z', '+00:00'))
                    published = pub_date.strftime('%Y-%m-%d')
                except:
                    published = published[:10] if len(published) >= 10 else ''
            
            return {
                'cve_id': vuln_id,
                'description': summary[:200] + '...' if len(summary) > 200 else summary,
                'cvss_score': cvss_score,
                'severity': severity,
                'published': published,
                'service': keyword,
                'version': version,
                'relevance_score': self._calculate_relevance(summary, keyword, version),
                'source': 'OSV'
            }
            
        except Exception as e:
            logger.warning(f"Error processing OSV data: {e}")
            return None
            
    def _process_circl_data(self, cve_data: Dict, keyword: str, version: str) -> Optional[Dict]:
        """Process CVE data from CIRCL API
        
        Args:
            cve_data: Raw CVE data from CIRCL API
            keyword: Service keyword
            version: Service version
            
        Returns:
            Processed vulnerability dictionary or None
        """
        try:
            cve_id = cve_data.get('id', 'Unknown')
            summary = cve_data.get('summary', 'No description available')
            
            # Get CVSS score and severity
            cvss_score = float(cve_data.get('cvss', 0))
            severity = self._score_to_severity(cvss_score)
            
            # Get published date
            published = cve_data.get('Published', '')
            if published:
                try:
                    published = published[:10]  # YYYY-MM-DD format
                except:
                    published = ''
            
            return {
                'cve_id': cve_id,
                'description': summary[:200] + '...' if len(summary) > 200 else summary,
                'cvss_score': cvss_score,
                'severity': severity,
                'published': published,
                'service': keyword,
                'version': version,
                'relevance_score': self._calculate_relevance(summary, keyword, version),
                'source': 'CIRCL'
            }
            
        except Exception as e:
            logger.warning(f"Error processing CIRCL data: {e}")
            return None
            
    def _severity_to_score(self, severity: str) -> float:
        """Convert severity string to CVSS score"""
        severity_map = {
            'CRITICAL': 9.0,
            'HIGH': 7.5,
            'MEDIUM': 5.0,
            'MODERATE': 5.0,
            'LOW': 2.5
        }
        return severity_map.get(severity.upper(), 0.0)
        
    def _score_to_severity(self, score: float) -> str:
        """Convert CVSS score to severity string"""
        if score >= 9.0:
            return 'CRITICAL'
        elif score >= 7.0:
            return 'HIGH'
        elif score >= 4.0:
            return 'MEDIUM'
        else:
            return 'LOW'
            
            
    def _calculate_relevance(self, description: str, keyword: str, version: str) -> float:
        """Calculate relevance score for a CVE
        
        Args:
            description: CVE description
            keyword: Service keyword
            version: Service version
            
        Returns:
            Relevance score (0.0 to 1.0)
        """
        score = 0.0
        description_lower = description.lower()
        
        # Exact keyword match
        if keyword.lower() in description_lower:
            score += 0.5
            
        # Version match
        if version != "unknown" and version in description_lower:
            score += 0.3
            
        # Generic service terms
        service_terms = ['remote', 'denial of service', 'buffer overflow', 'injection', 'authentication']
        for term in service_terms:
            if term in description_lower:
                score += 0.1
                break
                
        return min(score, 1.0)
        
    def _rate_limit(self):
        """Implement rate limiting for NVD API"""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        
        if time_since_last < self.request_interval:
            sleep_time = self.request_interval - time_since_last
            time.sleep(sleep_time)
            
        self.last_request_time = time.time()
        
    def _get_cache_file(self, keyword: str, version: str) -> Path:
        """Get cache file path for keyword/version combination
        
        Args:
            keyword: Service keyword
            version: Service version
            
        Returns:
            Path to cache file
        """
        filename = f"{keyword}_{version.replace('.', '_')}.json"
        return self.cache_dir / filename
        
    def _load_from_cache(self, cache_file: Path) -> Optional[List[Dict]]:
        """Load vulnerabilities from cache
        
        Args:
            cache_file: Path to cache file
            
        Returns:
            List of cached vulnerabilities or None
        """
        try:
            if not cache_file.exists():
                return None
                
            # Check if cache is recent (less than 24 hours old)
            mtime = datetime.fromtimestamp(cache_file.stat().st_mtime)
            if datetime.now() - mtime > timedelta(hours=24):
                return None
                
            with open(cache_file, 'r') as f:
                return json.load(f)
                
        except Exception as e:
            logger.warning(f"Error loading cache file {cache_file}: {e}")
            return None
            
    def _save_to_cache(self, cache_file: Path, vulnerabilities: List[Dict]):
        """Save vulnerabilities to cache
        
        Args:
            cache_file: Path to cache file
            vulnerabilities: List of vulnerabilities to cache
        """
        try:
            with open(cache_file, 'w') as f:
                json.dump(vulnerabilities, f, indent=2)
                
        except Exception as e:
            logger.warning(f"Error saving cache file {cache_file}: {e}")
            
    def generate_vulnerability_report(self, devices: List[Dict]) -> Dict:
        """Generate vulnerability summary report
        
        Args:
            devices: List of devices with vulnerability data
            
        Returns:
            Vulnerability report dictionary
        """
        total_devices = len(devices)
        vulnerable_devices = len([d for d in devices if d.get('vulnerability_count', 0) > 0])
        
        total_vulns = sum(d.get('vulnerability_count', 0) for d in devices)
        critical_vulns = sum(d.get('critical_vulns', 0) for d in devices)
        high_vulns = sum(d.get('high_vulns', 0) for d in devices)
        
        # Top vulnerabilities
        all_vulns = []
        for device in devices:
            for vuln in device.get('vulnerabilities', []):
                vuln_copy = vuln.copy()
                vuln_copy['device_ip'] = device.get('ip')
                all_vulns.append(vuln_copy)
                
        # Sort by CVSS score
        top_vulns = sorted(all_vulns, key=lambda x: x.get('cvss_score', 0), reverse=True)[:10]
        
        # Severity distribution
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0, 'UNKNOWN': 0}
        for vuln in all_vulns:
            severity = vuln.get('severity', 'UNKNOWN')
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
            
        return {
            'total_devices': total_devices,
            'vulnerable_devices': vulnerable_devices,
            'total_vulnerabilities': total_vulns,
            'critical_vulnerabilities': critical_vulns,
            'high_vulnerabilities': high_vulns,
            'severity_distribution': severity_counts,
            'top_vulnerabilities': top_vulns,
            'scan_timestamp': datetime.now().isoformat()
        }
        
    def _get_local_vulnerabilities(self, device: Dict) -> List[Dict]:
        """Get vulnerabilities using local knowledge base when API fails
        
        Args:
            device: Device dictionary
            
        Returns:
            List of vulnerability dictionaries
        """
        vulnerabilities = []
        services = device.get('services', [])
        open_ports = device.get('open_ports', [])
        
        # Expanded vulnerability patterns based on services and ports
        vuln_patterns = {
            'telnet': {
                'cve_id': 'LOCAL-TELNET-001',
                'description': 'Telnet transmits data in clear text, allowing potential eavesdropping and credential theft',
                'cvss_score': 7.5,
                'severity': 'HIGH',
                'source': 'Local Security Assessment'
            },
            'ftp': {
                'cve_id': 'LOCAL-FTP-001', 
                'description': 'FTP may transmit credentials in clear text, enabling credential interception',
                'cvss_score': 6.5,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            },
            'http': {
                'cve_id': 'LOCAL-HTTP-001',
                'description': 'HTTP traffic is unencrypted and may expose sensitive data and session cookies',
                'cvss_score': 5.3,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            },
            'snmp': {
                'cve_id': 'LOCAL-SNMP-001',
                'description': 'SNMP with default community strings can expose sensitive system information',
                'cvss_score': 5.8,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            },
            'ssh': {
                'cve_id': 'LOCAL-SSH-001',
                'description': 'SSH exposed to internet may be subject to brute force attacks',
                'cvss_score': 4.3,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            },
            'rlogin': {
                'cve_id': 'LOCAL-RLOGIN-001',
                'description': 'rlogin provides unencrypted remote access with weak authentication',
                'cvss_score': 8.1,
                'severity': 'HIGH',
                'source': 'Local Security Assessment'
            },
            'finger': {
                'cve_id': 'LOCAL-FINGER-001',
                'description': 'Finger service can leak user information to potential attackers',
                'cvss_score': 5.3,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            },
            'netbios': {
                'cve_id': 'LOCAL-NETBIOS-001',
                'description': 'NetBIOS services can expose system information and enable lateral movement',
                'cvss_score': 6.5,
                'severity': 'MEDIUM',
                'source': 'Local Security Assessment'
            }
        }
        
        # Port-specific vulnerabilities (for services without detailed info)
        port_patterns = {
            21: 'ftp',
            23: 'telnet', 
            79: 'finger',
            80: 'http',
            135: 'netbios',
            137: 'netbios',
            138: 'netbios',
            139: 'netbios',
            161: 'snmp',
            162: 'snmp',
            513: 'rlogin',
            445: 'netbios'
        }
        
        # Check services first
        found_services = set()
        for service in services:
            service_lower = service.lower()
            
            for pattern, vuln_data in vuln_patterns.items():
                if pattern in service_lower and pattern not in found_services:
                    vuln_copy = vuln_data.copy()
                    vuln_copy['service'] = service
                    vuln_copy['published'] = '2024-01-01'
                    vuln_copy['relevance_score'] = 0.8
                    vuln_copy['version'] = 'detected'
                    vulnerabilities.append(vuln_copy)
                    found_services.add(pattern)
                    
        # Check open ports for additional vulnerabilities
        for port in open_ports:
            try:
                port_num = int(port)
                if port_num in port_patterns:
                    pattern = port_patterns[port_num]
                    if pattern not in found_services and pattern in vuln_patterns:
                        vuln_data = vuln_patterns[pattern]
                        vuln_copy = vuln_data.copy()
                        vuln_copy['service'] = f"Port {port_num}"
                        vuln_copy['published'] = '2024-01-01'
                        vuln_copy['relevance_score'] = 0.6
                        vuln_copy['version'] = 'unknown'
                        vulnerabilities.append(vuln_copy)
                        found_services.add(pattern)
            except (ValueError, TypeError):
                continue
                    
        return vulnerabilities