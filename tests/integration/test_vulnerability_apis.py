"""Integration tests for vulnerability APIs"""

import pytest
import requests
import time
from pathlib import Path

from utils.vulnerability_scanner import VulnerabilityScanner


class TestVulnerabilityAPIs:
    """Test actual API connectivity and responses"""
    
    @pytest.fixture
    def scanner(self, tmp_path):
        """Create scanner instance with temp cache"""
        return VulnerabilityScanner(cache_dir=tmp_path / "cache")
    
    @pytest.mark.integration
    def test_osv_api_connectivity(self):
        """Test OSV API is accessible and returns expected format"""
        try:
            response = requests.post(
                'https://api.osv.dev/v1/query',
                json={'query': 'apache'},
                timeout=10
            )
            
            assert response.status_code == 200
            data = response.json()
            
            # Verify response structure
            assert isinstance(data, dict)
            assert 'vulns' in data
            assert isinstance(data['vulns'], list)
            
            # If vulnerabilities returned, check structure
            if data['vulns']:
                vuln = data['vulns'][0]
                assert 'id' in vuln
                assert 'summary' in vuln or 'details' in vuln
                
        except requests.exceptions.RequestException as e:
            pytest.skip(f"OSV API not accessible: {e}")
    
    @pytest.mark.integration
    def test_circl_api_connectivity(self):
        """Test CIRCL API is accessible and returns expected format"""
        try:
            response = requests.get(
                'https://cve.circl.lu/api/search/apache',
                timeout=10
            )
            
            assert response.status_code == 200
            data = response.json()
            
            # Verify response structure
            assert isinstance(data, list)
            
            # If CVEs returned, check structure
            if data:
                cve = data[0]
                assert 'id' in cve
                assert 'summary' in cve
                # CIRCL may return cvss as number or null
                assert 'cvss' in cve
                
        except requests.exceptions.RequestException as e:
            pytest.skip(f"CIRCL API not accessible: {e}")
    
    @pytest.mark.integration
    def test_api_fallback_chain(self, scanner):
        """Test the complete API fallback chain"""
        test_device = {
            'ip': '192.168.1.1',
            'services': ['apache:80', 'ssh:22'],
            'open_ports': [80, 22]
        }
        
        # Test full scan (will use actual APIs if available)
        result = scanner.scan_devices([test_device])
        
        assert len(result) == 1
        device = result[0]
        
        # Should have vulnerability data (from APIs or local patterns)
        assert 'vulnerability_count' in device
        assert 'vulnerabilities' in device
        assert isinstance(device['vulnerabilities'], list)
        
        # Should have found at least SSH vulnerability from local patterns
        if device['vulnerability_count'] > 0:
            sources = [v.get('source', '') for v in device['vulnerabilities']]
            # Check if we got results from any source
            assert any(source in ['OSV', 'CIRCL', 'Local Security Assessment'] 
                      for source in sources)
    
    @pytest.mark.integration
    def test_real_service_lookup(self, scanner):
        """Test looking up real vulnerabilities for known services"""
        # Apache - likely to have CVEs
        vulns = scanner._query_multi_apis('apache', '2.4.41')
        
        # Should return some vulnerabilities (unless APIs are down)
        # If APIs are down, this will return empty list
        assert isinstance(vulns, list)
        
        if vulns:
            # Verify vulnerability structure
            vuln = vulns[0]
            assert 'cve_id' in vuln
            assert 'severity' in vuln
            assert 'cvss_score' in vuln
            assert vuln['cvss_score'] >= 0
            assert vuln['source'] in ['OSV', 'CIRCL']
    
    @pytest.mark.integration
    def test_rate_limiting(self, scanner):
        """Test rate limiting between API calls"""
        start_time = time.time()
        
        # Make two API calls
        scanner._query_osv_api('test1')
        scanner._query_osv_api('test2')
        
        elapsed = time.time() - start_time
        
        # Should have delayed at least 2 seconds between calls
        assert elapsed >= scanner.request_interval
    
    @pytest.mark.integration
    def test_cache_functionality(self, scanner):
        """Test caching prevents duplicate API calls"""
        # First call - should hit API
        result1 = scanner._get_service_vulnerabilities('apache:80')
        
        # Second call - should use cache
        start_time = time.time()
        result2 = scanner._get_service_vulnerabilities('apache:80')
        elapsed = time.time() - start_time
        
        # Cache hit should be very fast (< 0.1 seconds)
        assert elapsed < 0.1
        
        # Results should be identical
        assert len(result1) == len(result2)
    
    @pytest.mark.integration
    def test_malformed_service_handling(self, scanner):
        """Test handling of malformed service strings"""
        # These should not crash the scanner
        services = [
            '',
            'invalid:format:multiple:colons',
            'no-port',
            ':80',  # No service name
            'service:abc',  # Non-numeric port
        ]
        
        for service in services:
            result = scanner._get_service_vulnerabilities(service)
            # Should return empty list, not crash
            assert isinstance(result, list)
    
    @pytest.mark.integration  
    def test_full_device_scan_with_apis(self, scanner):
        """Test complete device vulnerability scan using real APIs"""
        devices = [
            {
                'ip': '192.168.1.1',
                'hostname': 'test-router',
                'services': ['ssh:22', 'telnet:23'],
                'open_ports': [22, 23],
                'type': 'router'
            },
            {
                'ip': '192.168.1.10',
                'hostname': 'web-server',
                'services': ['apache:80 (Apache 2.4.41)', 'mysql:3306'],
                'open_ports': [80, 3306],
                'type': 'server'
            }
        ]
        
        # Scan devices
        result = scanner.scan_devices(devices)
        
        # Verify all devices processed
        assert len(result) == 2
        
        # Each device should have vulnerability fields
        for device in result:
            assert 'vulnerability_count' in device
            assert 'critical_vulns' in device
            assert 'high_vulns' in device
            assert 'vulnerabilities' in device
            
            # Router should have telnet vulnerability (high severity)
            if device['type'] == 'router':
                assert device['vulnerability_count'] >= 1
                # Local pattern for telnet is HIGH severity
                if device['vulnerabilities']:
                    telnet_vulns = [v for v in device['vulnerabilities'] 
                                   if 'telnet' in v.get('service', '').lower()]
                    if telnet_vulns:
                        assert any(v['severity'] == 'HIGH' for v in telnet_vulns)
    
    @pytest.mark.integration
    def test_api_error_recovery(self, scanner):
        """Test recovery from API errors"""
        # Temporarily break API URLs
        original_urls = scanner.apis.copy()
        scanner.apis['osv']['url'] = 'https://invalid.example.com/api'
        scanner.apis['circl']['url'] = 'https://invalid.example.com/api'
        
        # Should fall back to local patterns
        device = {
            'ip': '192.168.1.1',
            'services': ['telnet:23'],
            'open_ports': [23]
        }
        
        result = scanner.scan_devices([device])
        
        # Should still get results from local patterns
        assert len(result) == 1
        assert result[0]['vulnerability_count'] > 0
        
        # Restore URLs
        scanner.apis = original_urls